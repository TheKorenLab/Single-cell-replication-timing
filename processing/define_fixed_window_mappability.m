% Mask 20kb fixed-size windows where < 75% of nucleotide positions
% are not uniquely mappable

% Use 100bp mappability mask generated by TIGER
load('data/hg37_genome_metadata.mat', 'chrom_size', 'genome_windows')

is_mappable = cell(22, 1);
for Chr = 1:22
   
    masked = load('data/hg37_mappability_100bp.mat', ['chr' num2str(Chr)]);
    masked = masked.(['chr' num2str(Chr)]);
    
    assert(chrom_size(Chr) == size(masked, 1), 'Mappability mask is the wrong shape.')

    num_unmasked = NaN(size(genome_windows{Chr}, 1), 1);
    for w = 1:size(genome_windows{Chr}, 1)
        num_unmasked(w) = sum(~masked(genome_windows{Chr}(w, 1)+1:genome_windows{Chr}(w, 2)-1));
    end
    
    window_width = genome_windows{Chr}(:, 2) - genome_windows{Chr}(:, 1);
    is_mappable{Chr} = num_unmasked ./ window_width > 0.75;
    
end

% Mask contiguous segments between gaps if they contain < 50 mappable windows (1Mb)

% Gap list fetched from:
% https://hgdownload.cse.ucsc.edu/goldenPath/hg19/database/gap.txt.gz
fid = fopen('data/hg37.gaps.txt');
infile = textscan(fid, '%f%s%f%f%*[^\n]', 'Delimiter', '\t', 'CollectOutput', true);
fclose(fid);

contigs = cell(22, 1);
for Chr = 1:22
    is_chr = strcmp(infile{2}, ['chr' num2str(Chr)]);
    gaps = infile{3}(is_chr, :);
    gaps = sort([0; gaps(:); chrom_size(Chr)]);
    contigs{Chr} = [gaps(1:2:end-1) gaps(2:2:end)];
    contigs{Chr} = contigs{Chr}(contigs{Chr}(:, 1) ~= contigs{Chr}(:, 2), :);
end

for Chr = 1:22
    for c = 1:size(contigs{Chr}, 1)
        win = floor(contigs{Chr}(c, :) ./ 20e3) + 1;
        if sum(is_mappable{Chr}(win(1):win(2))) < 50
            is_mappable{Chr}(win(1):win(2), :) = false;
        end
    end
end

save('-append', 'data/hg37_genome_metadata.mat', 'is_mappable', 'contigs')
clearvars -except samples
